name: Auto-merge when ready

on:
  pull_request_target:            # runs with write perms even for forks
    types: [opened, synchronize, reopened]
  check_suite:                    # fires again when CI completes
    types: [completed]

jobs:
  automerge:
    # skip drafts
    if: |
      (!github.event.pull_request || github.event.pull_request.draft == false)
    runs-on: self-hosted
    container:
      image: node:20

    permissions:
      contents: write
      pull-requests: write
      statuses: read

    steps:
      - name: Merge PR if possible
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            let   pr;
            let   pull_number;

            // ---------------- identify the PR ----------------
            if (context.eventName === 'pull_request_target') {
              pr = context.payload.pull_request;
              pull_number = pr.number;
            } else {                               // check_suite
              const prs = context.payload.check_suite.pull_requests;
              if (!prs || prs.length === 0) {
                core.info('check_suite completed but has no related PR – exit');
                return;
              }
              pull_number = prs[0].number;
              pr = (await github.rest.pulls.get({ owner, repo, pull_number })).data;
            }

            core.info(`▶ Evaluating PR #${pull_number} (${pr.head.ref} → ${pr.base.ref})`);

            // ---------------- wait until mergeability is known ----------------
            let attempts = 0;
            while (pr.mergeable_state === 'unknown' && attempts < 10) {
              await new Promise(r => setTimeout(r, 3000));
              pr = (await github.rest.pulls.get({ owner, repo, pull_number })).data;
              attempts++;
            }
            core.info(`mergeable_state = ${pr.mergeable_state}`);

            // ---------------- handle each state ----------------
            if (pr.mergeable_state === 'behind') {
              core.info('Branch behind base – updating branch …');
              await github.rest.pulls.updateBranch({ owner, repo, pull_number });
              return;
            }

            if (['clean', 'unstable'].includes(pr.mergeable_state)) {
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number,
                merge_method: 'merge'        // change to 'squash' if preferred
              });
              core.info('✅ PR merged');
              return;
            }

            const reason =
              { dirty: 'merge conflicts',
                blocked: 'required reviews or checks missing',
                draft: 'draft PR' }[pr.mergeable_state] ?? pr.mergeable_state;

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pull_number,
              body: `⚠️ Auto-merge skipped: ${reason}.`
            });
            core.setFailed(`Auto-merge skipped: ${reason}`);

